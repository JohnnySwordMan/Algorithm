## 归并排序  
### 思路  
1. 对于两个有序数组，可以很方便地将其合并成一个数组，且时间复杂度为O(n)。代码如下：  
```  
public void merge(int[] a,int[] b,int[] c){
     int i=0,j=0,k=0;
     while(i<=a.length && j<=b.length){
          if(a[i]<=b[j]){
               c[k++] = a[i++];
          } else{
               c[k++] = b[j++];
          }
     }
     while(i<=a.length){
          c[k++] = a[i++];
     }
     while(j<=b.length){
          c[k++] = b[j++];
     }
}  
```   
2. 由上可知，对于无序数组的排序，可先将其划分为两个有序数组，然后再将两个有序数组合并成一个有序数组。  
3. 归并排序：将待排序数组通过递归的方式，向下不断划分成子数组，直至数组中只有一个元素的时候，可认为该数组有序，然后将数组向上合并成一个数组。总之：归并排序就是先递归，再合并。  
### 代码   
```
        private static void sort( int[] array, int left , int right) {
              if (left < right ) {
                     int mid = (left + right ) / 2;
                     sort( array, left, mid);
                     sort( array, mid + 1, right);
                     merge( array, left, mid, right);
             }
        }

        private static void merge( int[] array, int left , int mid, int right) {
              int [] temp = new int[ array. length];
              int i = left ;
              int j = mid + 1;
              int k = 0;
              while (i <= mid && j <= right) {
                     if (array [i ] <= array [j ]) {  
                            temp[ k++] = array[ i++];
                    } else {
                            temp[ k++] = array[ j++];
                    }
             }
              while (i <= mid ) {
                     temp[ k++] = array[ i++];
             }
              while (j <= right ) {
                     temp[ k++] = array[ j++];
             }
              // left是起始点，将临时数组中的内容存储到原数组中
              for (i = 0; i < k ; i ++) {
                     array[ i + left] = temp[ i];
             }
        }    
```  
### 复杂度   
1. 平均时间复杂度、最坏时间复杂度均为O(N*logN)  
2. 空间复杂度为O(N)  

### 稳定性  
1. 稳定性：在待排序的记录序列中，存在多个相同的关键字，在排序前后，相同关键字的相对位置保持不变，则该排序算法是稳定的，否则不稳定。  
2. 归并排序算法是稳定的。


