/**
 * 题目：拜访
 * 题目描述：
 * 现在有一个城市销售经理，需要从公司出发，去拜访市内的商家，已知他的位置以及商家的位置，但是由于城市道路交通的原因，他只能在左右中选择一个方向，在上下中选择一个方向，现在问他有多少种方案到达商家地址。
 * 给定一个地图map及它的长宽n和m，其中1代表经理位置，2代表商家位置，-1代表不能经过的地区，0代表可以经过的地区，请返回方案数，保证一定存在合法路径。保证矩阵的长宽都小于等于10。
 * 测试样例：
 * [[0,1,0],[2,0,0]],2,3
 * 返回：2
 * 
 * 分析：题目中"他只能在左右中选择一个方向，在上下中选择一个方向"应该理解为左右中只能选择一个方向，如果选择左，只能一直往左走。上下中只能选择一个方向，如果选择下，只能一直往下走。
 * 首先应该找出经理和商家的位置，注意从经理走向商家，与从商家走向经理的路径数是相同的，所以这里统一处理，从行坐标小的位置走到行坐标大的位置。
 * 所以，经理和商家的相对位置可以归纳为：
 * 1.两者处于主对角线上
 * 2.两者处于副对角线上
 * 3.两者重合或处于同一行，同一列(可以归纳到情况1和情况2)
 * 
 * 向左走向右走，可以使用动态规划
 * @author geyan
 *
 */
public class Visit {

	public int countPath(int[][] map, int n, int m) {
		// 1.找出经理和商家的位置
		int i, j;
		int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
		for (i = 0; i < n; i++) {
			for (j = 0; j < m; j++) {
				if (map[i][j] == 1) {
					x1 = i;
					y1 = j;
				} else if (map[i][j] == 2) {
					x2 = i;
					y2 = j;
				}
			}
		}
		// ---------------
		// 从1走到2与从2走到1的路径数是相同的，所以我统一从行坐标小的位置走到行坐标大的位置

		// 两点重合
		if (x1 == x2 && y1 == y2) {
			return 1;
		}
		// 交换x1与x2，y1与y2
		if (x1 > x2) {
			x1 = x1 ^ x2 ^ (x2 = x1);
			y1 = y1 ^ y2 ^ (y2 = y1);
		}

		int[][] dp = new int[n][m];
		if (y1 < y2) {
			// 两点处于主对角线上
			dp[x1][y1] = 1;
			// 向下
			for (i = x1 + 1; i <= x2; i++) {
				if (map[i][y1] == -1) {
					dp[i][y1] = 0;
				} else {
					dp[i][y1] = dp[i - 1][y1];
				}
			}
			// 向右
			for (j = y1 + 1; j <= y2; j++) {
				if (map[x1][j] == -1) {
					dp[x1][j] = 0;
				} else {
					dp[x1][j] = dp[x1][j - 1];
				}
			}
			for (i = x1 + 1; i <= x2; i++) {
				for (j = y1 + 1; j <= y2; j++) {
					if (map[i][j] == -1) {
						dp[i][j] = 0;
					} else {
						dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
					}
				}
			}
		} else {
			// 两点处在副对角线上
			dp[x1][y1] = 1;
			// 向下
			for (i = x1 + 1; i <= x2; i++) {
				if (map[i][y1] == -1) {
					dp[i][y1] = 0;
				} else {
					dp[i][y1] = dp[i - 1][y1];
				}
			}
			// 向左
			for (j = y1 - 1; j >= y2; j--) {
				if (map[x1][j] == -1) {
					dp[x1][j] = 0;
				} else {
					dp[x1][j] = dp[x1][j + 1];
				}
			}
			for (i = x1 + 1; i <= x2; i++) {
				for (j = y1 - 1; j >= y2; j--) {
					if (map[i][j] == -1) {
						dp[i][j] = 0;
					} else {
						dp[i][j] = dp[i - 1][j] + dp[i][j + 1];
					}
				}
			}
		}
		return dp[x2][y2];
	}
}
