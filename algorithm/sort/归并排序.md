## 归并排序  
### 思路  

 对于两个有序数组，可以很方便地将其合并成一个数组，且时间复杂度为`O(n)`。代码如下：  

  
```java  
public void merge(int[] a,int[] b,int[] c){
     int i=0,j=0,k=0;
     while(i<=a.length && j<=b.length){
          if(a[i]<=b[j]){
               c[k++] = a[i++];
          } else{
               c[k++] = b[j++];
          }
     }
     while(i<=a.length){
          c[k++] = a[i++];
     }
     while(j<=b.length){
          c[k++] = b[j++];
     }
}  
```   
 
2. 由上可知，对于无序数组的排序，可先将其划分为两个有序数组，然后再将`两个有序数组`合并成`一个有序数组`。  
3. **归并排序**：
	1. 将待排序数组通过递归的方式，向下不断划分成子数组，直至数组中只有一个元素的时候，可认为该数组有序，然后将数组向上合并成一个数组。总之：归并排序就是先分治，再合并。
	2. 核心思想：如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了。  


### 代码实现  

```java
public static void mergeSort(int[] array) {
	if(array == null || array.length == 1) {
		return;
	}
	sort(array, 0, array.length-1)
}

// 先分治，后合并
public static void sort(int[] array, int left, int right) {
	if(left < right) {  // 无须left<=right，提前处理
		int mid = left + (right - left)/2;  // (left + right)/2，可能出溢出
		sort(array, left, mid);
		sort(array, mid+1, right);
		merge(array, left, mid, right);
	}
}

public static void merge(int[] array, int left, int mid, int right) {
	int[] temp = new int[array.length];
	int i = left, j = mid+1;
	int k = 0;
	while(i <= mid && j <= right) {
		if(array[i] <= array[j]) {
			temp[k++] = array[i];
		} else {
			temp[k++] = array[j];
		}
	}
	while(i <= mid) {
		temp[k++] = array[i++];
	}
	while(j <= right) {
		temp[k++] = array[j++];
	}
	for(int m = 0; m < k; m++) {
		array[left + m] = temp[m];
	}
}
```  

### 复杂度   
1. 平均时间复杂度、最坏时间复杂度均为`O(n*logn)`  
2. 空间复杂度为`O(n)` 

### 稳定性  
1. 稳定性：在待排序的记录序列中，存在多个相同的关键字，在排序前后，相同关键字的相对位置保持不变，则该排序算法是稳定的，否则不稳定。  
2. 归并排序算法是稳定的。


